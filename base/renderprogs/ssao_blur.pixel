/*
===========================================================================

SSAO bilateral blur

Edge-preserving blur that uses depth stored in alpha channel to prevent
bleeding across depth discontinuities.

rpUser0: ( 1/screenWidth, 1/screenHeight, blurDirX, blurDirY )
  blurDir = (1,0) for horizontal, (0,1) for vertical

Textures:
  samp0 (s0): SSAO result texture
  samp1 (s1): depth buffer (currentDepthImage)

===========================================================================
*/

#include "global.inc"

uniform sampler2D samp0 : register(s0); // AO texture
uniform sampler2D samp1 : register(s1); // depth buffer

struct PS_IN {
	float2 texcoord0 : TEXCOORD0_centroid;
};

struct PS_OUT {
	float4 color : COLOR;
};

void main( PS_IN fragment, out PS_OUT result ) {
	float2 uv = fragment.texcoord0;
	float2 texelSize = rpUser0.xy;
	float2 blurDir = rpUser0.zw;

	// Gaussian weights for a 7-tap filter
	float weights[4];
	weights[0] = 0.266;
	weights[1] = 0.213;
	weights[2] = 0.121;
	weights[3] = 0.044;

	float4 centerSample = tex2D( samp0, uv );
	float centerDepth = centerSample.a;

	float3 colorSum = centerSample.rgb * weights[0];
	float weightSum = weights[0];

	// Depth threshold for edge detection - scaled by center depth to handle near/far
	float depthThreshold = 0.05;

	for ( float i = 1.0; i <= 3.0; i = i + 1.0 ) {
		int idx = int( i );

		// Positive direction
		float2 sampleUV = uv + blurDir * texelSize * i;
		float4 s = tex2D( samp0, sampleUV );
		float depthDiff = abs( s.a - centerDepth );
		float w = weights[idx] * ( 1.0 - step( depthThreshold, depthDiff ) );
		colorSum = colorSum + s.rgb * w;
		weightSum = weightSum + w;

		// Negative direction
		sampleUV = uv - blurDir * texelSize * i;
		s = tex2D( samp0, sampleUV );
		depthDiff = abs( s.a - centerDepth );
		w = weights[idx] * ( 1.0 - step( depthThreshold, depthDiff ) );
		colorSum = colorSum + s.rgb * w;
		weightSum = weightSum + w;
	}

	float3 blurred = colorSum / weightSum;
	result.color = float4( blurred, centerDepth );
}
